(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{132:function(a,_,t){"use strict";t.r(_);var v=t(0),e=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,_=a.$createElement,t=a._self._c||_;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"_3-kafka连接器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-kafka连接器","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.Kafka连接器")]),a._v(" "),t("h2",{attrs:{id:"_3-1-kafka认证连接器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-kafka认证连接器","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.1.Kafka认证连接器")]),a._v(" "),t("p",[a._v("Kafka连接器将Ignite和和Kafka集成在一起，从而将Ignite轻松地加入一个基于Kafka管道的系统中。")]),a._v(" "),t("p",[a._v("Kafka连接器具有扩展性和弹性，可以解决很多集成的难题，如果直接使用Kafka的"),t("code",[a._v("Producer")]),a._v("和"),t("code",[a._v("Consumer")]),a._v("API，则必须手工处理解决这些问题。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://files.readme.io/73b2ea2-What_is_Kafka_Connector-Ignite-Kafka_Connector.png",alt:""}})]),a._v(" "),t("h3",{attrs:{id:"_3-1-1-kafka连接器功能特性："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-kafka连接器功能特性：","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.1.1.Kafka连接器功能特性：")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("配置驱动")]),a._v("：无需编码，参见Kafka连接器配置的相关章节；")]),a._v(" "),t("li",[t("strong",[a._v("可扩展且灵活的架构")]),a._v("：参见Kafka连接器架构相关的章节，了解Kafka连接器如何满足性能、扩展性和容错的要求，并深入了解Kafka连接器的内部实现；")]),a._v(" "),t("li",[t("strong",[a._v("支持Ignite的数据模式")]),a._v("：参见Kafka连接器数据模式相关的章节，了解Kafka连接器如何识别、持有和更新Ignite的数据模式，以实现从Ignite到其它具有Kafka连接器的系统（比如Cassandra、HDFS和关系数据库等等）的自动化数据流；")]),a._v(" "),t("li",[t("strong",[a._v("易于运维")]),a._v("：参见Kafka连接器监控的相关章节，以了解如何在生产中监控Kafka连接器；")]),a._v(" "),t("li",[t("strong",[a._v("GridGain和社区版Kafka连接器")]),a._v("：参见GridGain和Ignite的Kafka连接器对比相关的章节，了解GridGain的Kafka连接器与开源版之间的区别。")])]),a._v(" "),t("h3",{attrs:{id:"_3-1-2-入门"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-入门","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.1.2.入门")]),a._v(" "),t("p",[a._v("参见Kafka连接器入门相关的章节，了解如何安装、配置和运行Kafka的连接器，然后看一些实际的示例：")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#_3-8-%E7%A4%BA%E4%BE%8B-%E4%BD%BF%E7%94%A8kafka%E8%BF%9E%E6%8E%A5%E5%99%A8%E5%9C%A8%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%8C%81%E4%B9%85%E5%8C%96ignite%E6%95%B0%E6%8D%AE"}},[a._v("示例：使用Kafka连接器在关系数据库中持久化Ignite数据")]),a._v(";")]),a._v(" "),t("li",[t("a",{attrs:{href:"#_3-9-%E7%A4%BA%E4%BE%8B-%E4%BD%BF%E7%94%A8kafka%E8%BF%9E%E6%8E%A5%E5%99%A8%E8%BF%9B%E8%A1%8Cignite%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"}},[a._v("示例：使用Kafka连接器进行Ignite数据复制")]),a._v("。")])]),a._v(" "),t("h2",{attrs:{id:"_3-2-kafka连接器入门"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-kafka连接器入门","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.2.Kafka连接器入门")]),a._v(" "),t("h3",{attrs:{id:"_3-2-1-kafka连接器生态系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-kafka连接器生态系统","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.2.1.Kafka连接器生态系统")]),a._v(" "),t("p",[a._v("在一个分布式的Kafka连接器生态系统中，有不同类型的节点，本文档中使用以下的术语来指代特定的节点类型：")]),a._v(" "),t("ul",[t("li",[a._v("Kafka集群节点被称为"),t("code",[a._v("Kafka代理")]),a._v("；")]),a._v(" "),t("li",[a._v("Kafka连接器集群节点被称为"),t("code",[a._v("Kafka连接器工作节点")]),a._v("；")]),a._v(" "),t("li",[a._v("GridGain集群节点被称为"),t("code",[a._v("GridGain服务端")]),a._v("。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://files.readme.io/37f4e2d-What_is_Kafka_Connector-Deployment.png",alt:""}})]),a._v(" "),t("h3",{attrs:{id:"_3-2-2-gridgain的kafka连接器安装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-gridgain的kafka连接器安装","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.2.2.GridGain的Kafka连接器安装")]),a._v(" "),t("p",[a._v("Kafka连接器安装分为3个步骤：")]),a._v(" "),t("ol",[t("li",[a._v("准备连接器安装包；")]),a._v(" "),t("li",[a._v("在Kafka中注册GridGain连接器；")]),a._v(" "),t("li",[a._v("在GridGain中注册连接器（可选）。")])]),a._v(" "),t("p",[t("strong",[a._v("1.准备连接器安装包")])]),a._v(" "),t("p",[a._v("Kafka连接器是GridGain企业版或旗舰版8.4.9及以后版本的一部分，位于GridGain安装文件夹的"),t("code",[a._v("integration/gridgain-kafka-connect")]),a._v("目录中。")]),a._v(" "),t("p",[a._v("然后拉取缺失的依赖项：")]),a._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[a._v("cd")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$GRIDGAIN_HOME")]),a._v("/integration/gridgain-kafka-connect\n./copy-dependencies.sh\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("p",[t("strong",[a._v("2.在Kafka中注册GridGain连接器")])]),a._v(" "),t("p",[a._v("对于每个Kafka的连接器工作节点：")]),a._v(" "),t("ol",[t("li",[a._v("将连接器包目录复制到期望的目标目录；")]),a._v(" "),t("li",[a._v("编辑Kafka连接器工作节点的配置（对于单工作节点Kafka连接器集群，编辑"),t("code",[a._v("$KAFKA_HOME/config/connect-standalone.properties")]),a._v("文件，对于多工作节点Kafka连接器集群，编辑"),t("code",[a._v("$KAFKA_HOME/config/connect-distributed.properties")]),a._v("），在插件目录中注册连接器，将"),t("code",[a._v("CONNECTORS_PATH")]),a._v("替换为之前复制的连接器安装包目录：")])]),a._v(" "),t("p",[a._v("connect-standalone.properties：")]),a._v(" "),t("div",{staticClass:"language-properties line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-properties"}},[t("code",[t("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("plugin.path")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("CONNECTORS_PATH/gridgain-kafka-connect")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[t("strong",[a._v("3.在GridGain中注册连接器")])]),a._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",{staticClass:"custom-block-title"},[a._v("这是可选的")]),a._v(" "),t("p",[a._v("只有使用"),t("code",[a._v("BACKLOG")]),a._v("作为"),t("a",{attrs:{href:"#-3-3-1-2-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB-%E5%86%8D%E5%B9%B3%E8%A1%A1%E5%92%8C%E5%88%86%E5%8C%BA%E5%81%8F%E7%A7%BB%E9%87%8F"}},[a._v("故障恢复策略")]),a._v("时，这个步骤才是必须的。")])]),a._v(" "),t("p",[a._v("在每个GridGain的服务端节点，将下面的jar包复制到"),t("code",[a._v("$GRIDGAIN_HOME/libs/user")]),a._v("目录中：")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("gridgain-kafka-connect-8.4.9.jar")]),a._v("（位于GridGain节点的"),t("code",[a._v("$GRIDGAIN_HOME/integration/gridgain-kafka-connect/lib")]),a._v("目录中）；")]),a._v(" "),t("li",[t("code",[a._v("connect-api-2.0.0.jar")]),a._v("和"),t("code",[a._v("kafka-clients-2.0.0.jar")]),a._v("（位于Kafka连接器工作节点的"),t("code",[a._v("$KAFKA_HOME/libs")]),a._v("目录）。")])]),a._v(" "),t("h3",{attrs:{id:"_3-2-3-gridgain的kafka连接器配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-gridgain的kafka连接器配置","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.2.3.GridGain的Kafka连接器配置")]),a._v(" "),t("p",[a._v("GridGain源连接器的必要属性是连接器的名字、类名和描述如何接入GridGain源集群的Ignite的配置文件的路径，名为"),t("code",[a._v("gridgain-kafka-connect-source")]),a._v("的最小源连接器配置大致如下：")]),a._v(" "),t("p",[a._v("gridgain-kafka-connect-source.properties：")]),a._v(" "),t("div",{staticClass:"language-properties line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-properties"}},[t("code",[t("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("name")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("gridgain-kafka-connect-source")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("connector.class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("org.gridgain.kafka.source.IgniteSourceConnector")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("igniteCfg")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("IGNITE_CONFIG_PATH/ignite-server-source.xml")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br")])]),t("p",[a._v("在"),t("a",{attrs:{href:"#_3-5-1-%E6%BA%90%E8%BF%9E%E6%8E%A5%E5%99%A8"}},[a._v("源连接器")]),a._v("章节中有更详细的属性说明。")]),a._v(" "),t("p",[a._v("GridGain接收连接器的必要属性是连接器的名字、类名、数据流来源的主题列表和描述如何接入GridGain接收集群的Ignite的配置文件的路径，名为"),t("code",[a._v("gridgain-kafka-connect-sink")]),a._v("的最小接收连接器配置大致如下：")]),a._v(" "),t("p",[a._v("gridgain-kafka-connect-sink.properties：")]),a._v(" "),t("div",{staticClass:"language-properties line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-properties"}},[t("code",[t("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("name")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("gridgain-kafka-connect-sink")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("topics")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("topic1,topic2,topic3")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("connector.class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("org.gridgain.kafka.sink.IgniteSinkConnector")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("igniteCfg")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("IGNITE_CONFIG_PATH/ignite-server-sink.xml")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("p",[a._v("在"),t("a",{attrs:{href:"#_3-5-2-%E6%8E%A5%E6%94%B6%E8%BF%9E%E6%8E%A5%E5%99%A8"}},[a._v("池连接器")]),a._v("章节中有更详细的属性说明。")]),a._v(" "),t("h3",{attrs:{id:"_3-2-4-运行kafka连接器生态系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-4-运行kafka连接器生态系统","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.2.4.运行Kafka连接器生态系统")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://docs.confluent.io/current/connect/userguide.html#installing-and-configuring-kconnect-long",target:"_self",rel:"noopener noreferrer"}},[a._v("Kafka连接器的安装和配置")]),a._v("，可以看相关的文档，简要来说，要做如下的内容：")]),a._v(" "),t("ol",[t("li",[a._v("安装和配置Kafka的连接器；")]),a._v(" "),t("li",[a._v("配置和启动Zookeeper；")]),a._v(" "),t("li",[a._v("配置和启动Kafka代理；")]),a._v(" "),t("li",[a._v("配置和启动Kafka连接器工作节点。")])]),a._v(" "),t("p",[a._v("了解了如何安装和配置Kafka连接器之后，下面就在一台主机中，使用默认的Zookeeper、Kafka代理和Kafka连接器工作节点配置文件运行Kafka生态系统的shell命令（生产上通常来说要在单独的主机中运行每个节点）：")]),a._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$KAFKA_HOME")]),a._v("/bin/zookeeper-server-start.sh "),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$KAFKA_HOME")]),a._v("/config/zookeeper.properties\n"),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$KAFKA_HOME")]),a._v("/bin/kafka-server-start.sh "),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$KAFKA_HOME")]),a._v("/config/server.properties\n"),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$KAFKA_HOME")]),a._v("/bin/connect-standalone.sh \\\n\t"),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$KAFKA_HOME")]),a._v("/config/connect-standalone.properties \\\n\tgridgain-kafka-connect-source.properties \\\n\tgridgain-kafka-connect-sink.properties\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("h3",{attrs:{id:"_3-2-5-管理kafka连接器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-5-管理kafka连接器","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.2.5.管理Kafka连接器")]),a._v(" "),t("p",[a._v("每个Kafka工作节点都会暴露REST API，可以用来管理Kafka连接器（默认端口为8083），有关如何创建、删除、暂停和恢复连接器以及查看连接器和任务的状态，可以参见"),t("a",{attrs:{href:"https://docs.confluent.io/current/connect/references/restapi.html",target:"_self",rel:"noopener noreferrer"}},[a._v("Kafka连接器REST接口")]),a._v("文档。")]),a._v(" "),t("h2",{attrs:{id:"_3-3-kafka连接器架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-kafka连接器架构","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.3.Kafka连接器架构")]),a._v(" "),t("h3",{attrs:{id:"_3-3-1-源连接器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-源连接器","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.3.1.源连接器")]),a._v(" "),t("p",[a._v("GridGain的源连接器会从Ignite缓存中加载数据，然后注入Kafka主题，该连接器会监控Ignite中缓存的新增和删除，然后自动进行调整。")]),a._v(" "),t("h4",{attrs:{id:"_3-3-1-1-并行化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-1-并行化","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.3.1.1.并行化")]),a._v(" "),t("p",[a._v("在Kafka中，"),t("strong",[a._v("分区")]),a._v("是键/值/时间戳记录的流。与其它分布式系统类似，Kafka在节点之间分配分区以实现高可用性、可伸缩性和性能。\nKafka连接器架构是分层的："),t("strong",[a._v("连接器")]),a._v("会将输入分成分区，创建多个"),t("strong",[a._v("任务")]),a._v("并为每个任务分配一个或多个分区，最大任务数是可配置的。")]),a._v(" "),t("p",[a._v("GridGain源连接器将每个Ignite缓存视为分区。换句话说，负载由缓存平衡：如果只有一个缓存进行数据加载，这时就是非分布式（独立）GridGain Kafka源连接器操作模式。")]),a._v(" "),t("p",[a._v("在Kafka中，分区存储在"),t("strong",[a._v("主题")]),a._v("中（Kafka"),t("strong",[a._v("生产者")]),a._v("写入以及Kafka"),t("strong",[a._v("消费者")]),a._v("读取的地方），因此，GridGain的Kafka源连接器是在Ignite缓存和Kafka主题之间映射数据。")]),a._v(" "),t("h4",{attrs:{id:"_3-3-1-2-故障转移、再平衡和分区偏移量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-2-故障转移、再平衡和分区偏移量","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.3.1.2.故障转移、再平衡和分区偏移量")]),a._v(" "),t("p",[t("strong",[a._v("再平衡")]),a._v("即将Kafka连接器和任务在"),t("strong",[a._v("工作节点")]),a._v("（Kafka节点上运行的JVM进程）间重新分配，如下场景会发生再平衡：")]),a._v(" "),t("ul",[t("li",[a._v("节点加入或离开Kafka集群；")]),a._v(" "),t("li",[a._v("GridGain的Kafka源连接器检测到Ignite缓存（Kafka术语中的分区）被创建或被删除，然后自身请求再平衡。")])]),a._v(" "),t("p",[a._v("Kafka连接器提供源分区偏移量存储（不要与Kafka记录偏移量混淆），以支持在故障或任何其他原因导致的再平衡或重启后继续拉取数据。如果没有偏移量，连接器就必须从头开始重新加载所有数据，或丢失在连接器不可用期间生成的数据。例如，Confluent的文件源连接器将文件视为分区，并将文件中的位置视为偏移量，另一个例子是Confluent的JDBC源连接器将数据库表视为分区，将自增或时间戳字段值视为偏移量。")]),a._v(" "),t("p",[a._v("GridGain源连接器将"),t("strong",[a._v("缓存")]),a._v("作为"),t("strong",[a._v("分区")]),a._v("，通常没有适用于缓存的"),t("strong",[a._v("偏移量")]),a._v("概念。虽然实际Ignite数据模型中可能有缓存具有自增键或自增值字段，但这种情况并不像关系数据库或NoSQL数据模型那样常见，因此Kafka连接器要求所有缓存包含自增字段将严重限制适用性。")]),a._v(" "),t("p",[a._v("因此，GridGain的Kafka连接器暴露了不同的策略来管理故障转移和再平衡，作为性能、资源消耗和数据交付保证之间的折衷，具体可以使用"),t("code",[a._v("failoverPolicy")]),a._v("配置项来指定。")]),a._v(" "),t("p",[t("strong",[a._v("丢弃")])]),a._v(" "),t("p",[a._v("由于故障转移或再平衡而导致连接器停机期间发生的Ignite缓存更新丢失，此选项以丢失数据为代价提供最高性能。")]),a._v(" "),t("p",[t("strong",[a._v("完整快照")])]),a._v(" "),t("p",[a._v("每次连接器启动时都从Ignite缓存拉取所有数据。在再平衡或故障转移后始终重新加载所有数据并不违反Kafka保证：可以将重复数据注入Kafka。不过Ignite旨在存储大量的数据，因此除非所有缓存都非常小，否则每次连接器重启都重新加载所有数据并不可行。")]),a._v(" "),t("p",[t("strong",[a._v("临时缓存")])]),a._v(" "),t("p",[a._v("从最后提交的偏移量恢复。")]),a._v(" "),t("p",[a._v("连接器会在Ignite中创建一个特殊的Kafka临时缓存，其会复制所有的缓存数据并赋予偏移量。Kafka临时缓存由Kafka临时服务管理，该服务在Kafka连接器故障后仍然是在线状态。连接器从Kafka临时缓存中拉取数据，提交已处理的数据偏移量，并在失败或再平衡后从上次提交的偏移量中恢复。在连接器正常停止后，Kafka临时服务会被卸载，同时Kafka临时缓存也会被销毁。配置"),t("code",[a._v("backlogMemoryRegionName")]),a._v("可以对临时缓存的内存区、持久化以及其它的存储选项进行定义。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://files.readme.io/6adf577-Offset_Management.png",alt:""}})]),a._v(" "),t("p",[a._v("此选项支持"),t("strong",[a._v("只处理一次")]),a._v("的语义，不过会消耗额外的Ignite资源来管理Kafka临时缓存，由于额外的数据编组，效率也不高，并且在Ignite集群重启后会丢失。")]),a._v(" "),t("div",{staticClass:"warning custom-block"},[t("p",{staticClass:"custom-block-title"},[a._v("Ignite中配置Kafka临时缓存的内存区")]),a._v(" "),t("p",[a._v("如果使用Kafka临时缓存管理故障转移，必须在Ignite中配置专用于Kafka临时缓存的内存区，并为该内存区配置退出策略，以避免临时缓存无限增长。可以将内存区最大大小配置为足以避免在最坏情况下丢失数据的值。为了理解“最坏情况”，假定Ignite按照条目注入源缓存的速度将条目推送到Kafka临时缓存，源连接器不断拉取Kafka临时缓存并将数据注入Kafka，如果Kafka达不到Ignite的性能或Kafka不可用，那么数据可能会从临时缓存中退出而不会被注入Kafka。因此，临时缓存内存区的最大值，必须足以使所有数据在最长可能的停机时间内以最大速度注入Kafka。")]),a._v(" "),t("p",[a._v("临时缓存内存区的名字默认是"),t("code",[a._v("kafka-connect")]),a._v("，可以使用配置项"),t("code",[a._v("backlogMemoryRegionName")]),a._v("指定其它的名称。")])]),a._v(" "),t("p",[t("strong",[a._v("动态重新配置")])]),a._v(" "),t("p",[a._v("Kafka连接器会监控在Ignite中创建的匹配"),t("code",[a._v("cacheWhitelist")]),a._v("和"),t("code",[a._v("cacheBlacklist")]),a._v("的新缓存以及在连接器运行时删除的现有缓存，连接器会对自身自动重新配置，如果动态创建或销毁受监控的缓存，Kafka会进行再平衡。")]),a._v(" "),t("p",[t("strong",[a._v("初始数据加载")])]),a._v(" "),t("p",[t("code",[a._v("shallLoadInitialData")]),a._v("配置项控制是否在连接器启动时加载Ignite缓存中已有的数据。")]),a._v(" "),t("h3",{attrs:{id:"_3-3-2-接收连接器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-接收连接器","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.3.2.接收连接器")]),a._v(" "),t("p",[a._v("GridGain接收连接器会从Kafka主题中导出数据，然后注入Ignite缓存，如果该缓存在Ignite中不存在，则会创建。")]),a._v(" "),t("h4",{attrs:{id:"_3-3-2-1-并行化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-1-并行化","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.3.2.1.并行化")]),a._v(" "),t("p",[a._v("接收连接器会启动一个或多个任务（任务数量在"),t("code",[a._v("tasks.max")]),a._v("配置项中指定），并在可用的工作节点中进行分配。每个任务都会从"),t("code",[a._v("topics")]),a._v("配置项中指定的主题中拉取数据，将它们分组成批，然后将批量数据推送到与主题对应的缓存中。")]),a._v(" "),t("h4",{attrs:{id:"_3-3-2-2-故障转移、再平衡和分区偏移量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-2-故障转移、再平衡和分区偏移量","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.3.2.2.故障转移、再平衡和分区偏移量")]),a._v(" "),t("p",[a._v("连接器框架会自动提交已处理数据的偏移量，如果连接器重启，会从最后提交的偏移量中继续从Kafka中拉取数据。这提供了"),t("strong",[a._v("只处理一次")]),a._v("保证。")]),a._v(" "),t("h3",{attrs:{id:"_3-3-3-共同特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-3-共同特性","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.3.3.共同特性")]),a._v(" "),t("p",[t("strong",[a._v("序列化和反序列化")])]),a._v(" "),t("p",[a._v("当源连接器将记录注入Kafka时会发生序列化。当接收连接器从Kafka中消费记录时，会发生反序列化。")]),a._v(" "),t("p",[a._v("Kafka会将连接器的序列化分开处理。使用Kafka工作节点的配置项"),t("code",[a._v("key.converter")]),a._v("和"),t("code",[a._v("value.converter")]),a._v("可以指定负责序列化的可插拔"),t("code",[a._v("Converter")]),a._v("模块的类名。")]),a._v(" "),t("p",[a._v("GridGain的Kafka连接器包中包含"),t("code",[a._v("org.gridgain.kafka.IgniteBinaryConverter")]),a._v("，它会使用Ignite的二进制编组器对数据进行序列化。该转换器为无模式数据提供了最大的性能，因为它是连接器使用的原生Ignite二进制对象。"),t("code",[a._v("IgniteBinaryConverter")]),a._v("支持Kafka的模式序列化，因此可以在启用模式时使用。")]),a._v(" "),t("p",[a._v("也可以使用其它供应商的转换器替代，它们可以提供一些丰富的附加功能，例如支持模式版本控制的模式注册等。")]),a._v(" "),t("p",[t("strong",[a._v("过滤")])]),a._v(" "),t("p",[a._v("源和接收连接器都可以对从Ignite缓存中拉取或推送到Ignite缓存的数据进行过滤。")]),a._v(" "),t("p",[a._v("使用"),t("code",[a._v("cacheFilter")]),a._v("配置项可以指定实现"),t("code",[a._v("java.util.function.Predicate<org.gridgain.kafka.CacheEntry>")]),a._v("的自定义过滤器类名。")]),a._v(" "),t("p",[t("strong",[a._v("转换")])]),a._v(" "),t("p",[a._v("Kafka的"),t("strong",[a._v("单消息转换")]),a._v("（SMT）允许基于配置的消息结构和内容更改。参见"),t("a",{attrs:{href:"http://kafka.apache.org/documentation.html#connect_transforms",target:"_self",rel:"noopener noreferrer"}},[a._v("Kafka文档")]),a._v("以了解如何配置SMT。")]),a._v(" "),t("p",[t("strong",[a._v("数据模式")])]),a._v(" "),t("p",[a._v("参见"),t("a",{attrs:{href:"#_3-4-kafka%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F"}},[a._v("Kafka连接器数据模式")]),a._v("一节。")]),a._v(" "),t("h2",{attrs:{id:"_3-4-kafka连接器数据模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-kafka连接器数据模式","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.4.Kafka连接器数据模式")]),a._v(" "),t("p",[a._v("GridGain的Kafka连接器支持数据模式。这使得许多现有的非GridGain接收连接器可以理解使用GridGain源连接器注入的数据，而GridGain接收连接器也可以理解非GridGain源连接器注入的数据。")]),a._v(" "),t("h3",{attrs:{id:"_3-4-1-ignite类型支持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-1-ignite类型支持","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.4.1.Ignite类型支持")]),a._v(" "),t("p",[a._v("GridGain的源和接收连接器使用Ignite的二进制格式来处理Ignite数据。")]),a._v(" "),t("p",[a._v("下表提供了Kafka模式类型与已知逻辑类型和Ignite二进制类型之间的映射。")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("Kafka类型")]),a._v(" "),t("th",[a._v("Ignite类型")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("INT8")]),a._v(" "),t("td",[a._v("BYTE")])]),a._v(" "),t("tr",[t("td",[a._v("INT16")]),a._v(" "),t("td",[a._v("SHORT, CHAR")])]),a._v(" "),t("tr",[t("td",[a._v("INT32")]),a._v(" "),t("td",[a._v("INT")])]),a._v(" "),t("tr",[t("td",[a._v("INT64")]),a._v(" "),t("td",[a._v("LONG")])]),a._v(" "),t("tr",[t("td",[a._v("FLOAT32")]),a._v(" "),t("td",[a._v("FLOAT")])]),a._v(" "),t("tr",[t("td",[a._v("FLOAT64")]),a._v(" "),t("td",[a._v("DOUBLE")])]),a._v(" "),t("tr",[t("td",[a._v("BOOLEAN")]),a._v(" "),t("td",[a._v("BOOLEAN")])]),a._v(" "),t("tr",[t("td",[a._v("STRING")]),a._v(" "),t("td",[a._v("STRING, UUID, CLASS")])]),a._v(" "),t("tr",[t("td",[a._v("BYTES")]),a._v(" "),t("td",[a._v("BYTE_ARR")])]),a._v(" "),t("tr",[t("td",[a._v("ARRAY(valueSchema)")]),a._v(" "),t("td",[a._v("COL"),t("br"),a._v("SHORT_ARR"),t("br"),a._v("INT_ARR"),t("br"),a._v("LONG_ARR"),t("br"),a._v("FLOAT_ARR"),t("br"),a._v("DOUBLE_ARR"),t("br"),a._v("CHAR_ARR"),t("br"),a._v("BOOLEAN_ARR"),t("br"),a._v("DECIMA"),t("br"),a._v("L_ARR"),t("br"),a._v("STRING_ARR"),t("br"),a._v("UUID_ARR"),t("br"),a._v("DATE_ARR"),t("br"),a._v("OBJ_ARR"),t("br"),a._v("ENUM_ARR"),t("br"),a._v("TIME_ARR"),t("br"),a._v("DATE_ARR"),t("br"),a._v("TIMES"),t("br"),a._v("TAMP_ARR"),t("br"),a._v("DECIMAL_ARR")])]),a._v(" "),t("tr",[t("td",[a._v("MAP")]),a._v(" "),t("td",[a._v("MAP")])]),a._v(" "),t("tr",[t("td",[a._v("STRUCT")]),a._v(" "),t("td",[a._v("OBJ, BINARY_OBJ")])]),a._v(" "),t("tr",[t("td",[a._v("Date (逻辑类型)")]),a._v(" "),t("td",[a._v("DATE")])]),a._v(" "),t("tr",[t("td",[a._v("Time (逻辑类型)")]),a._v(" "),t("td",[a._v("TIME")])]),a._v(" "),t("tr",[t("td",[a._v("Timestamp (逻辑类型)")]),a._v(" "),t("td",[a._v("TIMESTAMP")])]),a._v(" "),t("tr",[t("td",[a._v("Decimal (逻辑类型)")]),a._v(" "),t("td",[a._v("DECIMAL")])])])]),a._v(" "),t("div",{staticClass:"warning custom-block"},[t("p",{staticClass:"custom-block-title"},[a._v("部分Ignite类型信息会丢失")]),a._v(" "),t("p",[a._v("如上所示，由于没有Kafka模式和逻辑类型与之对应，因此以下Ignite类型的类型信息将丢失：CHAR，UUID，CLASS和相应的数组。")])]),a._v(" "),t("div",{staticClass:"warning custom-block"},[t("p",{staticClass:"custom-block-title"},[a._v("基于Java注解的配置会丢失")]),a._v(" "),t("p",[a._v("GridGain的Kafka连接器没有导入和导出使用Java注释指定的字段信息。例如，Kafka中不存在基于注解配置的关系键、SQL可查询字段和索引。")]),a._v(" "),t("p",[a._v("使用基于配置的方法，可以为接收器缓存指定此类信息。")])]),a._v(" "),t("h3",{attrs:{id:"_3-4-2-更新和删除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-2-更新和删除","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.4.2.更新和删除")]),a._v(" "),t("p",[a._v("源连接器默认不会处理已删除的Ignite缓存条目。将"),t("code",[a._v("shallProcessRemovals")]),a._v("配置项设置为"),t("code",[a._v("true")]),a._v("可以使源连接器处理删除的数据。这时源连接器会将值为"),t("code",[a._v("null")]),a._v("的记录注入Kafka以表示该数据已被删除，然后接收连接器会删除值为"),t("code",[a._v("null")]),a._v("的数据。使用"),t("code",[a._v("null")]),a._v("作为值来表示数据已被删除是正常的，因为Ignite不支持"),t("code",[a._v("null")]),a._v("缓存值。")]),a._v(" "),t("p",[a._v("出于性能原因，接收连接器默认不支持已有的缓存条目更新。将"),t("code",[a._v("shallProcessUpdates")]),a._v("配置项设置为"),t("code",[a._v("true")]),a._v("可以使接收连接器更新已有的条目。")]),a._v(" "),t("h3",{attrs:{id:"_3-4-3-模式迁移"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-3-模式迁移","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.4.3.模式迁移")]),a._v(" "),t("p",[a._v("模式迁移对于GridGain连接器是隐式的。源和接收连接器都以跨平台的Ignite二进制格式拉取和推送缓存条目，这种格式本质上支持更改模式，Ignite缓存键和值是可以具有不同字段集的动态对象。")]),a._v(" "),t("p",[a._v("出于性能原因，源连接器会缓存键和值的模式，在拉取第一个缓存条目时模式被创建并复用于所有后续条目。仅当模式永远不会更改时，此方式才有效。设置"),t("code",[a._v("isSchemaDynamic")]),a._v("为"),t("code",[a._v("true")]),a._v("可以支持模式更改。")]),a._v(" "),t("h3",{attrs:{id:"_3-4-4-无模式操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-4-无模式操作","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.4.4.无模式操作")]),a._v(" "),t("p",[a._v("如果"),t("code",[a._v("isSchemaless")]),a._v("配置项设置为"),t("code",[a._v("true")]),a._v("，则源连接器不会生成模式。")]),a._v(" "),t("p",[a._v("禁用模式可以提高性能：连接器不会构建模式，也不会将键和值转换为Kafka格式，不过代价就是非GridGain接收转换器无法理解以Ignite二进制格式注入Kafka的数据。")]),a._v(" "),t("p",[a._v("部分场景禁用模式是有意义的：")]),a._v(" "),t("ul",[t("li",[a._v("已准备通过编码来扩展非Ignite转换器处理Ignite二进制对象以实现更高的性能；")]),a._v(" "),t("li",[a._v("如"),t("a",{attrs:{href:"#_3-9-%E7%A4%BA%E4%BE%8B-%E4%BD%BF%E7%94%A8kafka%E8%BF%9E%E6%8E%A5%E5%99%A8%E8%BF%9B%E8%A1%8Cignite%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"}},[a._v("示例：使用Kafka连接器进行Ignite数据复制")]),a._v("所示，其不需要模式，因为源端和接收端都是GridGain连接器。")])]),a._v(" "),t("h2",{attrs:{id:"_3-5-kafka连接器配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-kafka连接器配置","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.5.Kafka连接器配置")]),a._v(" "),t("p",[a._v("源和接收Kafka连接器都是自文档化的，下面的配置参考都是从"),t("code",[a._v("IgniteSourceConnectorConfig.conf().toRst()")]),a._v("和"),t("code",[a._v("IgniteSinkConnectorConfig.conf().toRst()")]),a._v("方法的输出中捕获的。")]),a._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",{staticClass:"custom-block-title"},[a._v("所有缓存配置相同")]),a._v(" "),t("p",[a._v("接收和源连接器都支持多个缓存，下面的所有配置项都可以用于所有的缓存，这样可以最大限度地减少配置量并提高一致性。但是可能需要为不同的缓存设置不同的配置项，解决方法是使用不同的配置文件部署连接器的多个实例。")])]),a._v(" "),t("h3",{attrs:{id:"_3-5-1-源连接器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-1-源连接器","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.5.1.源连接器")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("配置项")]),a._v(" "),t("th",[a._v("描述")]),a._v(" "),t("th",[a._v("类型")]),a._v(" "),t("th",[a._v("默认值")]),a._v(" "),t("th",[a._v("重要性")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[t("code",[a._v("failoverPolicy")])]),a._v(" "),t("td",[a._v("处理Kafka连接器工作节点故障以及再平衡的模式。选项包括："),t("br"),t("strong",[a._v("NONE")]),a._v("：在连接器由于故障或者再平衡下线期间发生的缓存更新会丢失，该选项提供了最高的性能；"),t("br"),t("strong",[a._v("FULL_SNAPSHOT")]),a._v("：每次连接器启动后都会拉取所有的数据，该选项可防止数据丢失，但只适用于小型缓存；"),t("br"),t("strong",[a._v("BACKLOG")]),a._v("：从最后提交处继续。连接器会在Ignite中创建一个专门的临时缓存，其数据复制自所有的缓存并被赋予偏移量，然后数据从该Kafka临时缓存拉取。该选项可防止数据丢失，但会消耗额外的Ignite资源来管理Kafka临时缓存，并由于额外的数据编组而效率较低。")]),a._v(" "),t("td",[a._v("string")]),a._v(" "),t("td",[a._v("NONE")]),a._v(" "),t("td",[a._v("高")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("igniteCfg")])]),a._v(" "),t("td",[a._v("Ignite配置文件的路径，如果未指定默认会使用"),t("code",[a._v("$IGNITE_HOME/config/default-config.xml")])]),a._v(" "),t("td",[a._v("string")]),a._v(" "),t("td"),a._v(" "),t("td",[a._v("高")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("shallLoadInitialData")])]),a._v(" "),t("td",[a._v("连接器启动时是否加载Ignite缓存中的已有数据。")]),a._v(" "),t("td",[a._v("boolean")]),a._v(" "),t("td",[a._v("true")]),a._v(" "),t("td",[a._v("高")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("shallProcessRemovals")])]),a._v(" "),t("td",[a._v("如果为"),t("code",[a._v("true")]),a._v("，连接器会处理删除的数据。这时连接器会往Kafka中注入值为"),t("code",[a._v("null")]),a._v("的数据来表示该数据已被删除。")]),a._v(" "),t("td",[a._v("boolean")]),a._v(" "),t("td",[a._v("false")]),a._v(" "),t("td",[a._v("中")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("backlogCacheName")])]),a._v(" "),t("td",[a._v("在Ignite中创建的临时缓存的名字，其数据复制自所有的缓存并被赋予偏移量，该配置项只有"),t("code",[a._v("failoverPolicy")]),a._v("配置为"),t("code",[a._v("BACKLOG")]),a._v("时才有效。")]),a._v(" "),t("td",[a._v("string")]),a._v(" "),t("td",[a._v("kafka-connect-backlog")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("backlogFlushFreq")])]),a._v(" "),t("td",[a._v("临时缓存服务将数据刷新到临时缓存的频率（毫秒），0表示该配置项被禁用。该配置项只有"),t("code",[a._v("failoverPolicy")]),a._v("配置为"),t("code",[a._v("BACKLOG")]),a._v("时才有效。")]),a._v(" "),t("td",[a._v("int")]),a._v(" "),t("td",[a._v("500")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("backlogMemoryRegionName")])]),a._v(" "),t("td",[a._v("Ignite中用于存储临时缓存的内存区名字，该配置项只有"),t("code",[a._v("failoverPolicy")]),a._v("配置为"),t("code",[a._v("BACKLOG")]),a._v("时才有效。")]),a._v(" "),t("td",[a._v("string")]),a._v(" "),t("td",[a._v("kafka-connect")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("backlogServiceName")])]),a._v(" "),t("td",[a._v("临时缓存服务名，其会管理Ignite中的临时缓存，该配置项只有"),t("code",[a._v("failoverPolicy")]),a._v("配置为"),t("code",[a._v("BACKLOG")]),a._v("时才有效。")]),a._v(" "),t("td",[a._v("string")]),a._v(" "),t("td",[a._v("kafka-connect-backlog-service")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("batchSize")])]),a._v(" "),t("td",[a._v("单批次发送给Kafka的最大数据量")]),a._v(" "),t("td",[a._v("int")]),a._v(" "),t("td",[a._v("10000")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("cacheBlacklist")])]),a._v(" "),t("td",[a._v("正则表达式列表，用于匹配不进行复制的缓存的名称。如果同时指定了"),t("code",[a._v("cacheWhitelist")]),a._v("和"),t("code",[a._v("cacheBlacklist")]),a._v("，则首先分析"),t("code",[a._v("cacheWhitelist")]),a._v("。")]),a._v(" "),t("td",[a._v("list")]),a._v(" "),t("td",[a._v("null")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("cacheFilter")])]),a._v(" "),t("td",[a._v("自定义"),t("code",[a._v("java.util.function.Predicate<org.gridgain.kafka.CacheEntry>")]),a._v("实现的类名，用于过滤从Ignite缓存中拉取的数据。")]),a._v(" "),t("td",[a._v("class")]),a._v(" "),t("td",[a._v("null")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("cacheListPollInterval")])]),a._v(" "),t("td",[a._v("轮询Ignite中存在的最新缓存列表的频率（毫秒）。")]),a._v(" "),t("td",[a._v("long")]),a._v(" "),t("td",[a._v("5000")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("cacheWhitelist")])]),a._v(" "),t("td",[a._v("正则表达式列表，用于匹配要进行复制的缓存的名称。")]),a._v(" "),t("td",[a._v("list")]),a._v(" "),t("td",[a._v("null")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("isSchemaDynamic")])]),a._v(" "),t("td",[a._v("键和值模式默认只被创建一次并被缓存，如果配置为"),t("code",[a._v("true")]),a._v("，则会检测模式的变更。")]),a._v(" "),t("td",[a._v("boolean")]),a._v(" "),t("td",[a._v("false")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("isSchemaless")])]),a._v(" "),t("td",[a._v("源连接器默认会生成缓存的键和值模式，如果配置为"),t("code",[a._v("false")]),a._v("则会禁用模式的生成，这会提高性能，但是非GridGain的接收连接器会无法理解数据的结构。")]),a._v(" "),t("td",[a._v("boolean")]),a._v(" "),t("td",[a._v("false")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("pollInterval")])]),a._v(" "),t("td",[a._v("轮询每个缓存中的新数据的频率（毫秒）。")]),a._v(" "),t("td",[a._v("long")]),a._v(" "),t("td",[a._v("2000")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("topicPrefix")])]),a._v(" "),t("td",[a._v("连接器将Ignite缓存中的数据拉取到Kafka主题中，该主题使用此前缀为缓存名添加前缀。")]),a._v(" "),t("td",[a._v("string")]),a._v(" "),t("td"),a._v(" "),t("td",[a._v("低")])])])]),a._v(" "),t("h3",{attrs:{id:"_3-5-2-接收连接器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-2-接收连接器","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.5.2.接收连接器")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("配置项")]),a._v(" "),t("th",[a._v("描述")]),a._v(" "),t("th",[a._v("类型")]),a._v(" "),t("th",[a._v("默认值")]),a._v(" "),t("th",[a._v("重要性")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[t("code",[a._v("igniteCfg")])]),a._v(" "),t("td",[a._v("Ignite配置文件的路径，如果未指定默认会使用"),t("code",[a._v("$IGNITE_HOME/config/default-config.xml")])]),a._v(" "),t("td",[a._v("string")]),a._v(" "),t("td"),a._v(" "),t("td",[a._v("高")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("shallProcessUpdates")])]),a._v(" "),t("td",[a._v("是否启用覆盖或删除缓存中的已有值，如果禁用，则接收连接器的性能会更好。")]),a._v(" "),t("td",[a._v("boolean")]),a._v(" "),t("td",[a._v("false")]),a._v(" "),t("td",[a._v("中")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("batchSize")])]),a._v(" "),t("td",[a._v("单批次发送给Ignite的最大数据量")]),a._v(" "),t("td",[a._v("int")]),a._v(" "),t("td",[a._v("10000")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("cacheFilter")])]),a._v(" "),t("td",[a._v("自定义"),t("code",[a._v("java.util.function.Predicate<javax.cache.event.CacheEntryEvent>")]),a._v("实现的类名，用于过滤推送给Ignite缓存的数据。")]),a._v(" "),t("td",[a._v("class")]),a._v(" "),t("td",[a._v("null")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("cachePrefix")])]),a._v(" "),t("td",[a._v("接收缓存名是根据此前缀和没有主题前缀的Kafka主题名生成的。例如，如果主题为"),t("code",[a._v("ignite.person")]),a._v("，则主题前缀为"),t("code",[a._v("ignite")]),a._v("，然后缓存前缀是"),t("code",[a._v("ignite-")]),a._v("，那么接收缓存名就是"),t("code",[a._v("ignite-person")]),a._v("。")]),a._v(" "),t("td",[a._v("string")]),a._v(" "),t("td"),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("concurrency")])]),a._v(" "),t("td",[a._v("将数据推送给Ignite的并行线程数。如果配置为0或未指定，连接器将根据工作节点的CPU的数量选择默认数字。")]),a._v(" "),t("td",[a._v("int")]),a._v(" "),t("td",[a._v("0")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("keyFields")])]),a._v(" "),t("td",[a._v("用于Ignite缓存键的以逗号分隔的字段名称列表。如果"),t("code",[a._v("keyPolicy")]),a._v("设置为"),t("code",[a._v("kafka")]),a._v("，则不适用。如果未指定，则使用所有字段。")]),a._v(" "),t("td",[a._v("list")]),a._v(" "),t("td"),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("keyPolicy")])]),a._v(" "),t("td",[a._v("指定用于Ignite缓存键的数据，选项包括："),t("br"),t("strong",[a._v("key")]),a._v("：使用条目键中的字段；"),t("br"),t("strong",[a._v("value")]),a._v("：使用条目值中的字段；"),t("br"),t("strong",[a._v("kafka")]),a._v("：Ignite二进制对象有3个字段（Kafka记录的主题、分区和偏移量）用作缓存键。")]),a._v(" "),t("td",[a._v("string")]),a._v(" "),t("td",[a._v("key")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("pushInterval")])]),a._v(" "),t("td",[a._v("将数据推送到Ignite的频率（毫秒）。")]),a._v(" "),t("td",[a._v("long")]),a._v(" "),t("td",[a._v("2000")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("topicPrefix")])]),a._v(" "),t("td",[a._v("Kafka主题是根据此前缀和缓存名生成的。")]),a._v(" "),t("td",[a._v("string")]),a._v(" "),t("td",[a._v("ignite-")]),a._v(" "),t("td",[a._v("低")])]),a._v(" "),t("tr",[t("td",[t("code",[a._v("valueFields")])]),a._v(" "),t("td",[a._v("以逗号分隔的正则表达式列表，用于匹配用于Ignite缓存值的字段名。如果未指定，则使用所有字段。")]),a._v(" "),t("td",[a._v("list")]),a._v(" "),t("td"),a._v(" "),t("td",[a._v("低")])])])])])}],!1,null,null,null);e.options.__file="KafkaConnector.md";_.default=e.exports}}]);